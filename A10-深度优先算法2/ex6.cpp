/*
李逍遥的婶婶病了，王小虎介绍他去一趟仙灵岛，向仙女姐姐要仙丹救婶婶。
叛逆但孝顺的李逍遥闯进了仙灵岛，克服了千险万难来到岛的中心，发现仙药摆在了迷阵的深处。
迷阵由 M×N 个方格组成，有的方格内有可以瞬秒李逍遥的怪物，而有的方格内则是安全。
现在李逍遥想尽快找到仙药，显然他应避开有怪物的方格，并经过最少的方格，而且那里会有神秘人物等待着他。
现在要求你来帮助他实现这个目标。

提示
数据范围：
(1≤N,M≤2000) 
注意，这个范围隐含了一个重要的提示：你的程序必须是高效的。是选择BSF还是DFS？或者是其他的算法？

样例说明：
样例一：按照 下右右下下下右右下下 循序移动找到仙药
样例二：按照 上上上上左左上左 循序移动找到仙药
样例三：无法通过移动找到仙药

输入格式
第一行两个非零整数 M 和 N 开始，两者均不大于 2000。M 表示迷阵行数, N 表示迷阵列数。接下来有 M 行, 每行包含 N 个字符,不同字符分别代表不同含义:

1)‘@’：少年李逍遥所在的位置；
2)‘.’：可以安全通行的方格；
3)‘#’：有怪物的方格；
4)‘*’：仙药所在位置。

输出格式
输出一行，该行包含李逍遥找到仙药需要穿过的最少的方格数目。如果他不可能找到仙药, 则输出 −1。

样例组输入#1
8 8
.@##...#
#....#.#
#.#.##..
..#.###.
#.#...#.
..###.#.
...#.*..
.#...###
样例组输出#1
10

样例组输入#2
6 5
.*.#.
.#...
..##.
.....
.#...
....@
样例组输出#2
8

样例组输入#3
9 6
.#..#.
.#.*.#
.####.
..#...
..#...
..#...
..#...
#.@.##
.#..#.
样例组输出#3
-1
*/

#include <iostream>
#include <queue>
using namespace std;

// 常量定义
const int direction[4][2] = {{-1, 0}, {1, 0}, {0, -1}, {0, 1}}; // 上下左右
const int MAX = 2000; // 迷阵的最大行数和列数，数据范围：(1≤N,M≤2000)
// *********************************************************************************************************
// 注意：MAX的值隐含了一个重要的提示：你的程序必须是高效的（2000*2000=4000000），是选择BFS还是DFS？或者是其他的算法？
// *********************************************************************************************************

// 全局变量
int M, N; // 迷阵的行数和列数
char maze[MAX][MAX]; // 用于存储迷阵
bool visited[MAX][MAX]; // 用于标记节点是否访问过
struct Node {
    int x; // 节点横坐标
    int y; // 节点纵坐标
    int steps; // steps 表示到达该节点的步数
    Node(int x, int y, int steps) : x(x), y(y), steps(steps) {}
};
queue<Node> q; // 队列，此算法的关键数据结构，用于存储可访问的节点

// 检查一个位置是否在迷阵范围内，并且可以安全通过，且没有访问过
bool canPass(int x, int y) {
    return x >= 0 && x < M && y >= 0 && y < N && maze[x][y] != '#' && !visited[x][y]; // 不越 && 不是怪物 && 没有访问过
}

// BFS函数，用于寻找最短路径
int bfs(int startX, int startY) {
    q.push(Node(startX, startY, 0)); // 将起始节点入队
    visited[startX][startY] = true; // 标记起始节点已访问

    // 队列不为空，表示还有节点可访问，以BFS的方式继续遍历
    while (!q.empty()) {
        Node current = q.front(); // 取出队首节点作为当前节点
        q.pop(); // 弹出队首节点

        // 判断是否找到仙药
        if (maze[current.x][current.y] == '*') {
            return current.steps; // 返回到达仙药的步数，即最短路径，结束程序
        }

        // 遍历当前节点的四个方向
        for (int i = 0; i < 4; ++i) { // i=0 表示向上，i=1 表示向下，i=2 表示向左，i=3 表示向右
            int newX = current.x + direction[i][0];
            int newY = current.y + direction[i][1];
            if (canPass(newX, newY)) { // 如果新位置不越界，且不是怪物，且没有访问过
                visited[newX][newY] = true; // 标记新位置已访问
                q.push(Node(newX, newY, current.steps + 1)); // 将新位置入队，并且步数加 1
            }
        }
    }

    return -1; // 如果队列为空，表示已无法继续访问，仙药不可达，返回 -1
}

int main() {

    // 输入迷阵的行数和列数
    cin >> M >> N;

    // 输入迷阵，同时记录起始位置
    int startX, startY;
    for (int i = 0; i < M; ++i) {
        for (int j = 0; j < N; ++j) {
            cin >> maze[i][j];
            if (maze[i][j] == '@') {
                startX = i;
                startY = j;
            }
            visited[i][j] = false; // 初始状态，所有节点都没有访问过
        }
    }

    int result = bfs(startX, startY); // 用BFS寻找最短路径
    cout << result << endl; // 输出结果

    return 0;
}