// 假设输入的 n 是不超过 50 的正整数，d[i][0]、d[i][1] 都是不超过 10000 的正整数，请分析下面代码的用途
// 这段代码的用途是求解一个点集的最大权重和，其中权重的计算方式是任意两点的 x 坐标之和再加上 y 坐标之差的绝对值。相邻的两个点可合并为一个点。这个问题可以通过 DFS 暴力搜索所有可能的合并方式来解决。

#include <algorithm>
#include <iostream>
using namespace std;

int n; // n个点
int d[50][2]; // n个点的二维坐标
int ans; // 

void dfs(int n, int sum)
{
    if (n == 1) // 递归终止条件，只剩一个点
    {
        ans = max(sum, ans);
        return;
    }
    for (int i = 1; i < n; ++i) // 从第二个点开始遍历
    {
        int a = d[i - 1][0], b = d[i - 1][1]; // 保存第一个点的坐标
        int x = d[i][0], y = d[i][1]; // 保存第二个点的坐标
        d[i - 1][0] = a + x; // 将两个点合并为一个点
        d[i - 1][1] = b + y;
        for (int j = i; j < n - 1; ++j) // 将后面的点向前移动
            d[j][0] = d[j + 1][0], d[j][1] = d[j + 1][1];
        int s = a + x + abs(b - y); // 某种权重的计算 ？？？
        dfs(n - 1, sum + s); // 递归调用
        for (int j = n - 1; j > i; --j) // 回溯，恢复后面的点的状态
            d[j][0] = d[j - 1][0], d[j][1] = d[j - 1][1];
        d[i - 1][0] = a, d[i - 1][1] = b; // 恢复原来的第一个点的状态
        d[i][0] = x, d[i][1] = y; // 恢复原来的第二个点的状态
    }
}

int main()
{
    cin >> n;
    for (int i = 0; i < n; ++i)
        cin >> d[i][0]; // 输入n个点的x坐标
    for (int i = 0; i < n; ++i)
        cin >> d[i][1]; // 输入n个点的y坐标
    ans = 0;
    dfs(n, 0); // 初始调用，n个点，总和为0
    cout << ans << endl;
    return 0;
}

/*
程序状态分析：
假设 n=3,
d = [ [1,2], [3,4], [5,6] ]

初始调用
dfs(3, 0) 还剩3个点，总和为0
for(i=1, i=2)
    i=1
    a = 1, b = 2, x = 3, y = 4
    合并d[0]和d[1]，d[0][0] = 1 + 3 = 4, d[0][1] = 2 + 4 = 6
    后面的点依次往前移，d[1][0] = 5, d[1][1] = 6
    d = [ [4,6], [5,6], [5,6] ]
    s = a + x + abs(b - y) = 1 + 3 + abs(2 - 4) = 6
    dfs(2, 0+6) 还剩2个点，总和为6
    for(i=1)
        i=1
        a = 4, b = 6, x = 5, y = 6
        合并d[0]和d[1]，d[0][0] = 4 + 5 = 9, d[0][1] = 6 + 6 = 12
        后面没有要前移的点
        d = [ [9,12], [5,6], [5,6] ]
        s = a + x + abs(b - y) = 4 + 5 + abs(6 - 6) = 9
        dfs(1, 6+9) 还剩1个点，总和为15
            递归终止，ans = max(15, 0) = 15
        回溯，没有要移动的点
        恢复原来的第一个点的状态，d[0][0] = a, d[0][1] = b;
        恢复原来的第二个点的状态， d[1][0] = x, d[1][1] = y;
        d = [ [4,6], [5,6], [5,6] ]
    回溯，恢复后面的点的状态，d[2][0] = d[1][0] = 5, d[2][1] = d[1][1] = 6
    恢复原来的第一个点的状态，d[0][0] = a, d[0][1] = b;
    恢复原来的第二个点的状态， d[1][0] = x, d[1][1] = y;
    d = [ [1, 2], [3, 4], [5, 6] ]
    i=2
    a = d[1][0] = 3, b = d[1][1] = 4, x = d[2][0] = 5, y = d[2][1] = 6
    合并d[1]和d[2]，d[1][0] = 3 + 5 = 8, d[1][1] = 4 + 6 = 10
    后面没有要前移的点
    d = [ [1, 2], [8, 10], [5, 6] ]
    s = a + x + abs(b - y) = 3 + 5 + abs(4 - 6) = 10
    dfs(2, 0+10) 还剩2个点，总和为8
    for(i=1)
        i=1
        a = 1, b = 2, x = 8, y = 10
        合并d[0]和d[1]，d[0][0] = 1 + 8 = 9, d[0][1] = 2 + 10 = 12
        后面没有要前移的点
        d = [ [9, 12], [5, 6], [5, 6] ]
        s = a + x + abs(b - y) = 1 + 8 + abs(2 - 10) = 17
        dfs(1, 10+17) 还剩1个点，总和为27
            递归终止，ans = max(27, 15) = 27
        回溯，没有要移动的点
        恢复原来的第一个点的状态，d[0][0] = a = 1, d[0][1] = b = 2;
        恢复原来的第二个点的状态，d[1][0] = x = 8, d[1][1] = y = 10;
        d = [ [1, 2], [8, 10], [5, 6] ]
    回溯，后面没有要移动的点
    恢复原来的第一个点的状态，d[1][0] = a = 3, d[1][1] = b = 4;
    恢复原来的第二个点的状态，d[2][0] = x = 5, d[2][1] = y = 6;
    d = [ [1, 2], [3, 4], [5, 6] ]

最终得到 ans=27

*/

